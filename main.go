package main

  import(
    "io/ioutil"
    "log"
    "path/filepath"
    "time"
    "github.com/btcsuite/btcd/chaincfg/chainhash"
    "github.com/btcsuite/btcutil"
    "github.com/btcsuite/btcrpcclient"
  )



  func main() {


    ntfnHandlers := btcrpcclient.NotificationHandlers {

    // Handler for OnBlockConnected
  		OnBlockConnected: func(hash *chainhash.Hash, height int32, time time.Time) {
  			log.Printf("Block connected: %v (%d) %v", hash, height, time)
  		},

      // Handler for OnBlockDisconnected
  		OnBlockDisconnected: func(hash *chainhash.Hash, height int32, time time.Time) {
  			log.Printf("Block disconnected: %v (%d) %v", hash, height, time)
  		},


      // Handler for if transaction got accepted into Blockchain:
      OnTxAccepted: func(hash *chainhash.Hash,amount btcutil.Amount) {
        log.Printf("New Transaction accepted: %v For Amount: %d\n", hash, amount)
      },


  	}






          // Load the certificate for the TLS connection which is automatically
          // generated by btcd when it starts the RPC server and doesn't already
          // have one.
          btcdHomeDir := btcutil.AppDataDir("btcd", false)
          certs, err := ioutil.ReadFile(filepath.Join(btcdHomeDir, "rpc.cert"))
          if err != nil {
                  log.Fatal(err)
          }

          // Create a new RPC client using websockets.  Since this example is
          // not long-lived, the connection will be closed as soon as the program
          // exits.

          //rpcuser=0T3QrrHZZYFmJMqi2gkVHlkilV8=
          //rpcpass=D0EjPmwxAiSvMHZ59irNz4HWSXI=

          connCfg := &btcrpcclient.ConnConfig{
                  Host:         "localhost:8334",
                  Endpoint:     "ws",
                  User:         "587e5a3af2",
                  Pass:         "PoWLVsQgqSzhbwjDoCUJ",
                  Certificates: certs,
          }
          client, err := btcrpcclient.New(connCfg, &ntfnHandlers)
        	if err != nil {
        		log.Fatal(err)
        	}
/*
        	// Register for block connect and disconnect notifications.
        	if err := client.NotifyBlocks(); err != nil {
        		log.Fatal(err)
        	}
        	log.Println("NotifyBlocks: Registration Complete")

          */

        // Register for transaction accepted notifications.
        if err2 := client.NotifyNewTransactions(false); err != nil {
          log.Fatal(err2)
        }
        log.Println("NotifyNewTransactions: Registration Completed")

// Don't think we need this:
/*
        	// Get the current block count.
        	blockCount, err := client.GetBlockCount()
        	if err != nil {
        		log.Fatal(err)
        	}
        	log.Printf("Block count: %d", blockCount)
*/


// Wait until the client either shuts down gracefully (or the user
// terminates the process with Ctrl+C).
client.WaitForShutdown()


}
